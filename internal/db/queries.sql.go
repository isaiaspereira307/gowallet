// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"
)

const createBankAccount = `-- name: CreateBankAccount :exec
INSERT INTO bank_accounts (id, user_id, name, balance, created_at, updated_at) VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateBankAccountParams struct {
	ID        int32
	UserID    int32
	Name      string
	Balance   string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateBankAccount(ctx context.Context, arg CreateBankAccountParams) error {
	_, err := q.db.ExecContext(ctx, createBankAccount,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Balance,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createBitcoin = `-- name: CreateBitcoin :exec
INSERT INTO bitcoin (id, bank_account_id, purchase_price, quantity, purchase_date) VALUES ($1,$2,$3,$4,$5)
`

type CreateBitcoinParams struct {
	ID            int32
	BankAccountID int32
	PurchasePrice string
	Quantity      string
	PurchaseDate  time.Time
}

func (q *Queries) CreateBitcoin(ctx context.Context, arg CreateBitcoinParams) error {
	_, err := q.db.ExecContext(ctx, createBitcoin,
		arg.ID,
		arg.BankAccountID,
		arg.PurchasePrice,
		arg.Quantity,
		arg.PurchaseDate,
	)
	return err
}

const createFixedExpense = `-- name: CreateFixedExpense :exec
INSERT INTO fixed_expenses (id, bank_account_id, amount, description) VALUES ($1,$2,$3,$4)
`

type CreateFixedExpenseParams struct {
	ID            int32
	BankAccountID int32
	Amount        string
	Description   string
}

func (q *Queries) CreateFixedExpense(ctx context.Context, arg CreateFixedExpenseParams) error {
	_, err := q.db.ExecContext(ctx, createFixedExpense,
		arg.ID,
		arg.BankAccountID,
		arg.Amount,
		arg.Description,
	)
	return err
}

const createInvestment = `-- name: CreateInvestment :exec
INSERT INTO investments (id, bank_account_id, amount, created_at, updated_at) VALUES ($1,$2,$3,$4,$5)
`

type CreateInvestmentParams struct {
	ID            int32
	BankAccountID int32
	Amount        string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) CreateInvestment(ctx context.Context, arg CreateInvestmentParams) error {
	_, err := q.db.ExecContext(ctx, createInvestment,
		arg.ID,
		arg.BankAccountID,
		arg.Amount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createLoan = `-- name: CreateLoan :exec
INSERT INTO loans (id, bank_account_id, amount, interest_rate, due_date, created_at, updated_at) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type CreateLoanParams struct {
	ID            int32
	BankAccountID int32
	Amount        string
	InterestRate  string
	DueDate       time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) CreateLoan(ctx context.Context, arg CreateLoanParams) error {
	_, err := q.db.ExecContext(ctx, createLoan,
		arg.ID,
		arg.BankAccountID,
		arg.Amount,
		arg.InterestRate,
		arg.DueDate,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (id, bank_account_id, amount, timestamp, description, credit_debit) VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateTransactionParams struct {
	ID            int32
	BankAccountID int32
	Amount        string
	Timestamp     time.Time
	Description   string
	CreditDebit   bool
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.ID,
		arg.BankAccountID,
		arg.Amount,
		arg.Timestamp,
		arg.Description,
		arg.CreditDebit,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, name, email, password, created_at, updated_at) VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateUserParams struct {
	ID        int32
	Name      string
	Email     string
	Password  string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteBankAccount = `-- name: DeleteBankAccount :exec
DELETE FROM bank_accounts WHERE id = $1
`

func (q *Queries) DeleteBankAccount(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteBankAccount, id)
	return err
}

const deleteBitcoin = `-- name: DeleteBitcoin :exec
DELETE FROM bitcoin WHERE id = $1
`

func (q *Queries) DeleteBitcoin(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteBitcoin, id)
	return err
}

const deleteFixedExpense = `-- name: DeleteFixedExpense :exec
DELETE FROM fixed_expenses WHERE id = $1
`

func (q *Queries) DeleteFixedExpense(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteFixedExpense, id)
	return err
}

const deleteInvestment = `-- name: DeleteInvestment :exec
DELETE FROM investments WHERE id = $1
`

func (q *Queries) DeleteInvestment(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteInvestment, id)
	return err
}

const deleteLoan = `-- name: DeleteLoan :exec
DELETE FROM loans WHERE id = $1
`

func (q *Queries) DeleteLoan(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteLoan, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getBankAccountById = `-- name: GetBankAccountById :one
SELECT id, user_id, name, balance, created_at, updated_at FROM bank_accounts WHERE id = $1
`

func (q *Queries) GetBankAccountById(ctx context.Context, id int32) (BankAccount, error) {
	row := q.db.QueryRowContext(ctx, getBankAccountById, id)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Balance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBankAccountsByUserId = `-- name: GetBankAccountsByUserId :many
SELECT id, user_id, name, balance, created_at, updated_at FROM bank_accounts WHERE user_id = $1
`

func (q *Queries) GetBankAccountsByUserId(ctx context.Context, userID int32) ([]BankAccount, error) {
	rows, err := q.db.QueryContext(ctx, getBankAccountsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BankAccount
	for rows.Next() {
		var i BankAccount
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Balance,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBitcoinById = `-- name: GetBitcoinById :one
SELECT id, bank_account_id, purchase_price, quantity, purchase_date FROM bitcoin WHERE id = $1
`

func (q *Queries) GetBitcoinById(ctx context.Context, id int32) (Bitcoin, error) {
	row := q.db.QueryRowContext(ctx, getBitcoinById, id)
	var i Bitcoin
	err := row.Scan(
		&i.ID,
		&i.BankAccountID,
		&i.PurchasePrice,
		&i.Quantity,
		&i.PurchaseDate,
	)
	return i, err
}

const getBitcoinsByBankAccountId = `-- name: GetBitcoinsByBankAccountId :many
SELECT id, bank_account_id, purchase_price, quantity, purchase_date FROM bitcoin WHERE bank_account_id = $1
`

func (q *Queries) GetBitcoinsByBankAccountId(ctx context.Context, bankAccountID int32) ([]Bitcoin, error) {
	rows, err := q.db.QueryContext(ctx, getBitcoinsByBankAccountId, bankAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bitcoin
	for rows.Next() {
		var i Bitcoin
		if err := rows.Scan(
			&i.ID,
			&i.BankAccountID,
			&i.PurchasePrice,
			&i.Quantity,
			&i.PurchaseDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFixedExpenseById = `-- name: GetFixedExpenseById :one
SELECT id, bank_account_id, amount, description FROM fixed_expenses WHERE id = $1
`

func (q *Queries) GetFixedExpenseById(ctx context.Context, id int32) (FixedExpense, error) {
	row := q.db.QueryRowContext(ctx, getFixedExpenseById, id)
	var i FixedExpense
	err := row.Scan(
		&i.ID,
		&i.BankAccountID,
		&i.Amount,
		&i.Description,
	)
	return i, err
}

const getFixedExpensesByBankAccountId = `-- name: GetFixedExpensesByBankAccountId :many
SELECT id, bank_account_id, amount, description FROM fixed_expenses WHERE bank_account_id = $1
`

func (q *Queries) GetFixedExpensesByBankAccountId(ctx context.Context, bankAccountID int32) ([]FixedExpense, error) {
	rows, err := q.db.QueryContext(ctx, getFixedExpensesByBankAccountId, bankAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FixedExpense
	for rows.Next() {
		var i FixedExpense
		if err := rows.Scan(
			&i.ID,
			&i.BankAccountID,
			&i.Amount,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvestmentById = `-- name: GetInvestmentById :one
SELECT id, bank_account_id, amount, created_at, updated_at FROM investments WHERE id = $1
`

func (q *Queries) GetInvestmentById(ctx context.Context, id int32) (Investment, error) {
	row := q.db.QueryRowContext(ctx, getInvestmentById, id)
	var i Investment
	err := row.Scan(
		&i.ID,
		&i.BankAccountID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvestmentsByBankAccountId = `-- name: GetInvestmentsByBankAccountId :many
SELECT id, bank_account_id, amount, created_at, updated_at FROM investments WHERE bank_account_id = $1
`

func (q *Queries) GetInvestmentsByBankAccountId(ctx context.Context, bankAccountID int32) ([]Investment, error) {
	rows, err := q.db.QueryContext(ctx, getInvestmentsByBankAccountId, bankAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Investment
	for rows.Next() {
		var i Investment
		if err := rows.Scan(
			&i.ID,
			&i.BankAccountID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoanById = `-- name: GetLoanById :one
SELECT id, bank_account_id, amount, interest_rate, due_date, created_at, updated_at FROM loans WHERE id = $1
`

func (q *Queries) GetLoanById(ctx context.Context, id int32) (Loan, error) {
	row := q.db.QueryRowContext(ctx, getLoanById, id)
	var i Loan
	err := row.Scan(
		&i.ID,
		&i.BankAccountID,
		&i.Amount,
		&i.InterestRate,
		&i.DueDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLoansByBankAccountId = `-- name: GetLoansByBankAccountId :many
SELECT id, bank_account_id, amount, interest_rate, due_date, created_at, updated_at FROM loans WHERE bank_account_id = $1
`

func (q *Queries) GetLoansByBankAccountId(ctx context.Context, bankAccountID int32) ([]Loan, error) {
	rows, err := q.db.QueryContext(ctx, getLoansByBankAccountId, bankAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Loan
	for rows.Next() {
		var i Loan
		if err := rows.Scan(
			&i.ID,
			&i.BankAccountID,
			&i.Amount,
			&i.InterestRate,
			&i.DueDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionById = `-- name: GetTransactionById :one
SELECT id, bank_account_id, amount, timestamp, description, credit_debit FROM transactions WHERE id = $1
`

func (q *Queries) GetTransactionById(ctx context.Context, id int32) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionById, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.BankAccountID,
		&i.Amount,
		&i.Timestamp,
		&i.Description,
		&i.CreditDebit,
	)
	return i, err
}

const getTransactionsByBankAccountId = `-- name: GetTransactionsByBankAccountId :many
SELECT id, bank_account_id, amount, timestamp, description, credit_debit FROM transactions WHERE bank_account_id = $1
`

func (q *Queries) GetTransactionsByBankAccountId(ctx context.Context, bankAccountID int32) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBankAccountId, bankAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.BankAccountID,
			&i.Amount,
			&i.Timestamp,
			&i.Description,
			&i.CreditDebit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, name, email, password, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, name, email, password, created_at, updated_at FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBankAccount = `-- name: UpdateBankAccount :exec
UPDATE bank_accounts SET name = $1, balance = $2, updated_at = $3 WHERE id = $4
`

type UpdateBankAccountParams struct {
	Name      string
	Balance   string
	UpdatedAt time.Time
	ID        int32
}

func (q *Queries) UpdateBankAccount(ctx context.Context, arg UpdateBankAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateBankAccount,
		arg.Name,
		arg.Balance,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateBankAccountBalance = `-- name: UpdateBankAccountBalance :exec
UPDATE bank_accounts SET balance = $1 WHERE id = $2
`

type UpdateBankAccountBalanceParams struct {
	Balance string
	ID      int32
}

func (q *Queries) UpdateBankAccountBalance(ctx context.Context, arg UpdateBankAccountBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBankAccountBalance, arg.Balance, arg.ID)
	return err
}

const updateBitcoin = `-- name: UpdateBitcoin :exec
UPDATE bitcoin SET purchase_price = $1, quantity = $2, purchase_date = $3 WHERE id = $4
`

type UpdateBitcoinParams struct {
	PurchasePrice string
	Quantity      string
	PurchaseDate  time.Time
	ID            int32
}

func (q *Queries) UpdateBitcoin(ctx context.Context, arg UpdateBitcoinParams) error {
	_, err := q.db.ExecContext(ctx, updateBitcoin,
		arg.PurchasePrice,
		arg.Quantity,
		arg.PurchaseDate,
		arg.ID,
	)
	return err
}

const updateFixedExpense = `-- name: UpdateFixedExpense :exec
UPDATE fixed_expenses SET amount = $1, description = $2 WHERE id = $3
`

type UpdateFixedExpenseParams struct {
	Amount      string
	Description string
	ID          int32
}

func (q *Queries) UpdateFixedExpense(ctx context.Context, arg UpdateFixedExpenseParams) error {
	_, err := q.db.ExecContext(ctx, updateFixedExpense, arg.Amount, arg.Description, arg.ID)
	return err
}

const updateInvestment = `-- name: UpdateInvestment :exec
UPDATE investments SET amount = $1, updated_at = $2 WHERE id = $3
`

type UpdateInvestmentParams struct {
	Amount    string
	UpdatedAt time.Time
	ID        int32
}

func (q *Queries) UpdateInvestment(ctx context.Context, arg UpdateInvestmentParams) error {
	_, err := q.db.ExecContext(ctx, updateInvestment, arg.Amount, arg.UpdatedAt, arg.ID)
	return err
}

const updateLoan = `-- name: UpdateLoan :exec
UPDATE loans SET amount = $1, interest_rate = $2, due_date = $3, updated_at = $4 WHERE id = $5
`

type UpdateLoanParams struct {
	Amount       string
	InterestRate string
	DueDate      time.Time
	UpdatedAt    time.Time
	ID           int32
}

func (q *Queries) UpdateLoan(ctx context.Context, arg UpdateLoanParams) error {
	_, err := q.db.ExecContext(ctx, updateLoan,
		arg.Amount,
		arg.InterestRate,
		arg.DueDate,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE transactions SET amount = $1, timestamp = $2, description = $3, credit_debit = $4 WHERE id = $5
`

type UpdateTransactionParams struct {
	Amount      string
	Timestamp   time.Time
	Description string
	CreditDebit bool
	ID          int32
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, updateTransaction,
		arg.Amount,
		arg.Timestamp,
		arg.Description,
		arg.CreditDebit,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET name = $1, email = $2, password = $3, updated_at = $4 WHERE id = $5
`

type UpdateUserParams struct {
	Name      string
	Email     string
	Password  string
	UpdatedAt time.Time
	ID        int32
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
